package software.leonov.common.sql;

import static java.util.Objects.requireNonNull;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.sql.Savepoint;
import java.util.function.Consumer;

/**
 * Static utility methods for working with {@link Connection}s.
 * 
 * @author Zhenya Leonov
 */
final public class Connections {

    private Connections() {
    }

    /**
     * Returns a {@code FluentStatement} backed by an underlying {@code PreparedStatement} object for sending parameterized
     * SQL statements to the database.
     *
     * @param conn the database connection
     * @param sql  an SQL statement that may contain one or more '?' parameter placeholdeconn
     * @return a {@code FluentStatement} backed by an underlying {@code PreparedStatement} object for sending parameterized
     *         SQL statements to the database
     * @throws SQLException if a database access error occuconn or this method is called on a closed connection
     */
    public static FluentStatement prepare(final Connection conn, final String sql) throws SQLException {
        if (conn == null)
            throw new NullPointerException("conn == null");
        if (sql == null)
            throw new NullPointerException("sql == null");
        return new FluentStatement(conn.prepareStatement(sql), sql);
    }

    /**
     * Creates a {@code FluentStatement} backed by an underlying {@code PreparedStatement} object for sending parameterized
     * SQL statements to the database.
     *
     * @param conn              the database connection
     * @param sql               an SQL statement that may contain one or more '?' parameter placeholdeconn
     * @param autoGeneratedKeys a flag indicating whether auto-generated keys should be returned; one of
     *                          {@code Statement.RETURN_GENERATED_KEYS} or {@code Statement.NO_GENERATED_KEYS}
     * @return a {@code FluentStatement} backed by an underlying {@code PreparedStatement} object for sending parameterized
     *         SQL statements to the database
     * @throws SQLException                    if a database access error occuconn or this method is called on a closed
     *                                         connection
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method with a constant of
     *                                         {@code Statement.RETURN_GENERATED_KEYS}
     */
    public static FluentStatement prepare(final Connection conn, final String sql, final int autoGeneratedKeys) throws SQLException {
        if (conn == null)
            throw new NullPointerException("conn == null");
        if (sql == null)
            throw new NullPointerException("sql == null");
        return new FluentStatement(conn.prepareStatement(sql, autoGeneratedKeys), sql);
    }

    /**
     * Returns a {@code FluentStatement} backed by an underlying {@code PreparedStatement} object for sending parameterized
     * SQL statements to the database.
     *
     * @param conn          the database connection
     * @param sql           an SQL statement that may contain one or more '?' parameter placeholdeconn
     * @param columnIndexes an array of column indexes indicating the columns that should be returned from the inserted row
     *                      or rows
     * @return a {@code FluentStatement} backed by an underlying {@code PreparedStatement} object for sending parameterized
     *         SQL statements to the database
     * @throws SQLException                    if a database access error occuconn or this method is called on a closed
     *                                         connection
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     */
    public static FluentStatement prepare(final Connection conn, final String sql, final int[] columnIndexes) throws SQLException {
        if (conn == null)
            throw new NullPointerException("conn == null");
        if (sql == null)
            throw new NullPointerException("sql == null");
        if (columnIndexes == null)
            throw new NullPointerException("columnIndexes == null");
        return new FluentStatement(conn.prepareStatement(sql, columnIndexes), sql);
    }

    /**
     * Returns a {@code FluentStatement} backed by an underlying {@code PreparedStatement} object for sending parameterized
     * SQL statements to the database.
     *
     * @param conn        the database connection
     * @param sql         an SQL statement that may contain one or more '?' parameter placeholdeconn
     * @param columnNames an array of column names indicating the columns that should be returned from the inserted row or
     *                    rows
     * @return a {@code FluentStatement} backed by an underlying {@code PreparedStatement} object for sending parameterized
     *         SQL statements to the database
     * @throws SQLException                    if a database access error occuconn or this method is called on a closed
     *                                         connection
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     */
    public static FluentStatement prepare(final Connection conn, final String sql, final String[] columnNames) throws SQLException {
        if (conn == null)
            throw new NullPointerException("conn == null");
        if (sql == null)
            throw new NullPointerException("sql == null");
        if (columnNames == null)
            throw new NullPointerException("columnNames == null");
        return new FluentStatement(conn.prepareStatement(sql, columnNames), sql);
    }

    /**
     * Returns a {@code FluentStatement} backed by an underlying {@code PreparedStatement} object for sending parameterized
     * SQL statements to the database.
     *
     * @param conn                  the database connection
     * @param sql                   an SQL statement that may contain one or more '?' parameter placeholdeconn
     * @param ConnectionType        a result set type; one of {@code Connection.TYPE_FORWARD_ONLY},
     *                              {@code Connection.TYPE_SCROLL_INSENSITIVE}, or {@code Connection.TYPE_SCROLL_SENSITIVE}
     * @param ConnectionConcurrency a concurrency type; one of {@code Connection.CONCUR_READ_ONLY} or
     *                              {@code Connection.CONCUR_UPDATABLE}
     * @return a {@code FluentStatement} backed by an underlying {@code PreparedStatement} object for sending parameterized
     *         SQL statements to the database
     * @throws SQLException                    if a database access error occuconn or this method is called on a closed
     *                                         connection
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method or this method is not
     *                                         supported for the specified result set type and result set concurrency
     */
    public static FluentStatement prepare(final Connection conn, final String sql, final int ConnectionType, final int ConnectionConcurrency) throws SQLException {
        if (conn == null)
            throw new NullPointerException("conn == null");
        if (sql == null)
            throw new NullPointerException("sql == null");
        return new FluentStatement(conn.prepareStatement(sql, ConnectionType, ConnectionConcurrency), sql);
    }

    /**
     * Returns a {@code FluentStatement} backed by an underlying {@code PreparedStatement} object for sending parameterized
     * SQL statements to the database.
     *
     * @param conn                  the database connection
     * @param sql                   an SQL statement that may contain one or more '?' parameter placeholdeconn
     * @param ConnectionType        one of the following {@code Connection} constants: {@code Connection.TYPE_FORWARD_ONLY},
     *                              {@code Connection.TYPE_SCROLL_INSENSITIVE}, or {@code Connection.TYPE_SCROLL_SENSITIVE}
     * @param ConnectionConcurrency one of the following {@code Connection} constants: {@code Connection.CONCUR_READ_ONLY}
     *                              or {@code Connection.CONCUR_UPDATABLE}
     * @param ConnectionHoldability one of the following {@code Connection} constants:
     *                              {@code Connection.HOLD_CUconnOconn_OVER_COMMIT} or
     *                              {@code Connection.CLOSE_CUconnOconn_AT_COMMIT}
     * @return a {@code FluentStatement} backed by an underlying {@code PreparedStatement} object for sending parameterized
     *         SQL statements to the database
     * @throws SQLException                    if a database access error occuconn or this method is called on a closed
     *                                         connection
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method or this method is not
     *                                         supported for the specified result set type, result set holdability and
     *                                         result set concurrency
     */
    public static FluentStatement prepare(final Connection conn, final String sql, final int ConnectionType, final int ConnectionConcurrency, final int ConnectionHoldability) throws SQLException {
        if (conn == null)
            throw new NullPointerException("conn == null");
        if (sql == null)
            throw new NullPointerException("sql == null");
        return new FluentStatement(conn.prepareStatement(sql, ConnectionType, ConnectionConcurrency, ConnectionHoldability), sql);
    }

    /**
     * {@link Connection#rollback(Savepoint) Rollbacks} the specified {@code Connection} to the {@code Savepoint}, if it is
     * not {@code null}. If an error is thrown it will be {@link Throwable#addSuppressed(Throwable) appended} to the primary
     * exception.
     * <p>
     * This method is primarily useful when cleaning up resources in a catch/finally block stemming from an earlier error.
     * 
     * @param conn      the specified {@code Connection}
     * @param savepoint the {@code Savepoint} to roll back to
     * @param t         the primary exception which occurred earlier
     */
    public static void rollbackQuietly(final Connection conn, final Savepoint savepoint, final Throwable t) {
        requireNonNull(t, "t == null");
        rollbackQuietly(conn, t::addSuppressed);
    }

    /**
     * {@link Connection#rollback(Savepoint) Rollbacks} the specified {@code Connection} to the {@code Savepoint}, if it is
     * not {@code null}. If an error is thrown it will be {@link Consumer#accept(Object) passed} to the specified
     * {@code Consumer}.
     * <p>
     * This method is primarily useful when cleaning up resources in a catch/finally block stemming from an earlier error.
     * 
     * @param conn      the specified {@code Connection}
     * @param savepoint the {@code Savepoint} to roll back to
     * @param consumer  the {@code Consumer} which will handle the error
     */
    public static void rollbackQuietly(final Connection conn, final Savepoint savepoint, final Consumer<Throwable> consumer) {
        if (conn != null)
            try {
                conn.rollback(savepoint);
            } catch (final Throwable th) {
                consumer.accept(th);
            }
    }

    /**
     * {@link Connection#rollback() Rollbacks} the specified {@code Connection} if it is not {@code null}. If an error is
     * thrown it will be {@link Throwable#addSuppressed(Throwable) appended} to the primary exception.
     * <p>
     * This method is primarily useful when cleaning up resources in a catch/finally block stemming from an earlier error.
     * 
     * @param conn the specified {@code Connection}
     * @param t    the primary exception which occurred earlier
     */
    public static void rollbackQuietly(final Connection conn, final Throwable t) {
        requireNonNull(t, "t == null");
        rollbackQuietly(conn, t::addSuppressed);
    }

    /**
     * {@link Connection#rollback() Rollbacks} the specified {@code Connection} if it is not {@code null}. If an error is
     * thrown it will be {@link Consumer#accept(Object) passed} to the specified {@code Consumer}.
     * <p>
     * This method is primarily useful when cleaning up resources in a catch/finally block stemming from an earlier error.
     * 
     * @param conn     the specified {@code Connection}
     * @param consumer the {@code Consumer} which will handle the error
     */
    public static void rollbackQuietly(final Connection conn, final Consumer<Throwable> consumer) {
        if (conn != null)
            try {
                conn.rollback();
            } catch (final Throwable th) {
                consumer.accept(th);
            }
    }

    /**
     * Closes the specified {@code Connection} if it is not {@code null}. If an error is thrown it will be
     * {@link Throwable#addSuppressed(Throwable) appended} to the primary exception.
     * <p>
     * This method is primarily useful when cleaning up resources in a catch/finally block stemming from an earlier error.
     * 
     * @param conn the specified {@code Connection}
     * @param t    the primary exception which occurred earlier
     */
    public static void closeQuietly(final Connection conn, final Throwable t) {
        requireNonNull(t, "t == null");
        closeQuietly(conn, t::addSuppressed);
    }

    /**
     * Closes the specified {@code Connection} if it is not {@code null}. If an error is thrown it will be
     * {@link Consumer#accept(Object) passed} to the specified {@code Consumer}.
     * <p>
     * This method is primarily useful when cleaning up resources in a catch/finally block stemming from an earlier error.
     * 
     * @param conn     the specified {@code Connection}
     * @param consumer the {@code Consumer} which will handle the error
     */
    public static void closeQuietly(final Connection conn, final Consumer<Throwable> consumer) {
        if (conn != null)
            try {
                conn.close();
            } catch (final Throwable th) {
                consumer.accept(th);
            }
    }

}
