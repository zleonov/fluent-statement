package software.leonov.common.sql;

import java.io.InputStream;
import java.io.Reader;
import java.math.BigDecimal;
import java.net.URL;
import java.sql.Array;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.Date;
import java.sql.NClob;
import java.sql.PreparedStatement;
import java.sql.Ref;
import java.sql.ResultSet;
import java.sql.RowId;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.sql.SQLXML;
import java.sql.Statement;
import java.sql.Time;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.Calendar;

/**
 * A {@code FluentStatement} is a {@link PreparedStatement} that provides <i>bindXXXX</i> methods which return
 * <i>{@code this} statement instance</i> for users who prefer
 * <a href="http://en.wikipedia.org/wiki/Fluent_interface" target="_blank">fluency</a> as a style.
 * <p>
 * Instances of this class can be obtained by calling the various {@link Connections#prepare(Connection, String)
 * Connections.prepare} methods.
 * <p>
 * Additional functionality:
 * <ul>
 * <li>The ability to register a callback function via the {@link #onAddBatch(Runnable)} method which will be executed
 * after each call to {@code addBatch}.</li>
 * <li>The ability to retrieve the current batch size since the last call to {@link #executeBatch()} via the
 * {@link #getBatchSize()} method.</li>
 * <li>The ability to retrieve the the original SQL used to create this {@code FluentStatement} via
 * {@link #getSQL()}.</li>
 * </ul>
 * <p>
 * <b>Note:</b> While some driver implementations allow users to call the following {@link Statement} methods:
 * <ul>
 * <li>{@link #executeQuery(String)}</li>
 * <li>{@link #executeUpdate(String)}</li>
 * <li>{@link #execute(String)}</li>
 * <li>{@link #addBatch(String)}</li>
 * <li>{@link #executeUpdate(String, int)}</li>
 * <li>{@link #executeUpdate(String, int[])}</li>
 * <li>{@link #execute(String, int)}</li>
 * <li>{@link #execute(String, int[])}</li>
 * <li>{@link #execute(String, String[])}</li>
 * <li>{@link #execute(String)}</li>
 * </ul>
 * <p>
 * This class strictly adheres to the API specification which states that these <i>methods cannot be called on a
 * {@code PreparedStatement}s</i>. They are reserved for {@code Statement} implementations only and will result in
 * {@link SQLException}s.
 * 
 * @author Zhenya Leonov
 */
public final class FluentStatement extends ForwardingPreparedStatement {

    private final PreparedStatement statement;
    private final String            sql;
    private Runnable                callback  = null;
    private int                     batchSize = 0;

    FluentStatement(final PreparedStatement statement, final String sql) {
        this.statement = statement;
        this.sql       = sql;
    }

    @Override
    protected PreparedStatement delegate() {
        return statement;
    }

    @Override
    public void addBatch() throws SQLException {
        delegate().addBatch();
        batchSize++;
        if (callback != null)
            callback.run();
    }

    /**
     * <b>Note:</b> This method cannot be called on a PreparedStatement.
     * 
     * @throws SQLException always
     * @return this {@code FluentStatement} instance
     */
    @Override
    public void addBatch(String sql) throws SQLException {
        throw new SQLException("this method cannot be called on a PreparedStatement");
    }

    /**
     * Returns the current batch size.
     * 
     * @return the current batch size
     * @return this {@code FluentStatement} instance
     */
    public int getBatchSize() {
        return batchSize;
    }

    @Override
    public void clearBatch() throws SQLException {
        delegate().clearBatch();
        batchSize = 0;
    }

    /**
     * <b>Note:</b> This method cannot be called on a PreparedStatement.
     * 
     * @throws SQLException always
     * @return this {@code FluentStatement} instance
     */
    @Override
    public boolean execute(String sql) throws SQLException {
        throw new SQLException("this method cannot be called on a PreparedStatement");
    }

    /**
     * <b>Note:</b> This method cannot be called on a PreparedStatement.
     * 
     * @throws SQLException always
     * @return this {@code FluentStatement} instance
     */
    @Override
    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        throw new SQLException("this method cannot be called on a PreparedStatement");

    }

    /**
     * <b>Note:</b> This method cannot be called on a PreparedStatement.
     * 
     * @throws SQLException always
     * @return this {@code FluentStatement} instance
     */
    @Override
    public boolean execute(String sql, int columnIndexes[]) throws SQLException {
        throw new SQLException("this method cannot be called on a PreparedStatement");
    }

    /**
     * <b>Note:</b> This method cannot be called on a PreparedStatement.
     * 
     * @throws SQLException always
     * @return this {@code FluentStatement} instance
     */
    @Override
    public boolean execute(String sql, String columnNames[]) throws SQLException {
        throw new SQLException("this method cannot be called on a PreparedStatement");
    }

    @Override
    public int[] executeBatch() throws SQLException {
        final int[] ints = delegate().executeBatch();
        batchSize = 0;
        return ints;
    }

    /**
     * <b>Note:</b> This method cannot be called on a PreparedStatement.
     * 
     * @throws SQLException always
     * @return this {@code FluentStatement} instance
     */
    @Override
    public ResultSet executeQuery(String sql) throws SQLException {
        throw new SQLException("this method cannot be called on a PreparedStatement");
    }

    /**
     * <b>Note:</b> This method cannot be called on a PreparedStatement.
     * 
     * @throws SQLException always
     * @return this {@code FluentStatement} instance
     */
    @Override
    public int executeUpdate(String sql) throws SQLException {
        throw new SQLException("this method cannot be called on a PreparedStatement");
    }

    /**
     * <b>Note:</b> This method cannot be called on a PreparedStatement.
     * 
     * @throws SQLException always
     * @return this {@code FluentStatement} instance
     */
    @Override
    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        throw new SQLException("this method cannot be called on a PreparedStatement");
    }

    /**
     * <b>Note:</b> This method cannot be called on a PreparedStatement.
     * 
     * @throws SQLException always
     * @return this {@code FluentStatement} instance
     */
    @Override
    public int executeUpdate(String sql, int columnIndexes[]) throws SQLException {
        throw new SQLException("this method cannot be called on a PreparedStatement");
    }

    /**
     * <b>Note:</b> This method cannot be called on a PreparedStatement.
     * 
     * @throws SQLException always
     * @return this {@code FluentStatement} instance
     */
    @Override
    public int executeUpdate(String sql, String columnNames[]) throws SQLException {
        throw new SQLException("this method cannot be called on a PreparedStatement");
    }

    /**
     * Registers a callback function which will be invoked every time {@link #addBatch()} called.
     * 
     * @param callback the callback function
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement onAddBatch(final Runnable callback) {
        if (callback == null)
            throw new NullPointerException("callback == null");
        this.callback = callback;
        return this;
    }

    /**
     * Returns the sql command that was used to create this {@code FluentStatement}.
     * 
     * @return the sql command that was used to create this {@code FluentStatement}
     * @return this {@code FluentStatement} instance
     */
    public String getSQL() {
        return sql;
    }

    /**
     * Sets the designated parameter to the given {@code java.sql.Array} object. The driver converts this to an SQL
     * {@code ARRAY} value when it sends it to the database.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param x              an {@code Array} object that maps an SQL {@code ARRAY} value
     * @throws SQLException                    if parameterIndex does not correspond to a parameter placeholder in the SQL
     *                                         statement or if a database access error occurs or this method is called on a
     *                                         closed {@code PreparedStatement}
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindArray(int parameterIndex, Array x) throws SQLException {
        delegate().setArray(parameterIndex, x);
        return this;
    }

    /**
     * Sets the designated parameter to the given input stream. When a very large ASCII value is input to a
     * {@code LONGVARCHAR} parameter, it may be more practical to send it via a {@code java.io.InputStream}. Data will be
     * read from the stream as needed until end-of-file is reached. The JDBC driver will do any necessary conversion from
     * ASCII to the database char format.
     * <p>
     * <b>Note:</b> This stream object can either be a standard Java stream object or your own subclass that implements the
     * standard interface.
     * <p>
     * <b>Note:</b> Consult your JDBC driver documentation to determine if it might be more efficient to use a version of
     * {@code setAsciiStream} which takes a length parameter.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param in             the Java input stream that contains the ASCII parameter value
     * @throws SQLException                    if parameterIndex does not correspond to a parameter placeholder in the SQL
     *                                         statement or if a database access error occurs or this method is called on a
     *                                         closed {@code PreparedStatement}
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindAsciiStream(int parameterIndex, InputStream in) throws SQLException {
        delegate().setAsciiStream(parameterIndex, in);
        return this;
    }

    /**
     * Sets the designated parameter to the given input stream, which will have the specified number of bytes. When a very
     * large ASCII value is input to a {@code LONGVARCHAR} parameter, it may be more practical to send it via a
     * {@code java.io.InputStream}. Data will be read from the stream as needed until end-of-file is reached. The JDBC
     * driver will do any necessary conversion from ASCII to the database char format.
     * <p>
     * <b>Note:</b> This stream object can either be a standard Java stream object or your own subclass that implements the
     * standard interface.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param in             the Java input stream that contains the ASCII parameter value
     * @param length         the number of bytes in the stream
     * @throws SQLException if parameterIndex does not correspond to a parameter placeholder in the SQL statement or if a
     *                      database access error occurs or this method is called on a closed {@code PreparedStatement}
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindAsciiStream(int parameterIndex, InputStream in, int length) throws SQLException {
        delegate().setAsciiStream(parameterIndex, in, length);
        return this;
    }

    /**
     * Sets the designated parameter to the given input stream, which will have the specified number of bytes. When a very
     * large ASCII value is input to a {@code LONGVARCHAR} parameter, it may be more practical to send it via a
     * {@code java.io.InputStream}. Data will be read from the stream as needed until end-of-file is reached. The JDBC
     * driver will do any necessary conversion from ASCII to the database char format.
     * <p>
     * <b>Note:</b> This stream object can either be a standard Java stream object or your own subclass that implements the
     * standard interface.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param in             the Java input stream that contains the ASCII parameter value
     * @param length         the number of bytes in the stream
     * @throws SQLException if parameterIndex does not correspond to a parameter placeholder in the SQL statement or if a
     *                      database access error occurs or this method is called on a closed {@code PreparedStatement}
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindAsciiStream(int parameterIndex, InputStream in, long length) throws SQLException {
        delegate().setAsciiStream(parameterIndex, in, length);
        return this;
    }

    /**
     * Sets the designated parameter to the given {@code java.math.BigDecimal} value. The driver converts this to an SQL
     * {@code NUMERIC} value when it sends it to the database.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param x              the parameter value
     * @throws SQLException if parameterIndex does not correspond to a parameter placeholder in the SQL statement or if a
     *                      database access error occurs or this method is called on a closed {@code PreparedStatement}
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindBigDecimal(int parameterIndex, BigDecimal x) throws SQLException {
        delegate().setBigDecimal(parameterIndex, x);
        return this;
    }

    /**
     * Sets the designated parameter to the given input stream. When a very large binary value is input to a
     * {@code LONGVARBINARY} parameter, it may be more practical to send it via a {@code java.io.InputStream} object. The
     * data will be read from the stream as needed until end-of-file is reached.
     * <p>
     * <b>Note:</b> This stream object can either be a standard Java stream object or your own subclass that implements the
     * standard interface.
     * <p>
     * <b>Note:</b> Consult your JDBC driver documentation to determine if it might be more efficient to use a version of
     * {@code setBinaryStream} which takes a length parameter.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param in             the java input stream which contains the binary parameter value
     * @throws SQLException                    if parameterIndex does not correspond to a parameter placeholder in the SQL
     *                                         statement or if a database access error occurs or this method is called on a
     *                                         closed {@code PreparedStatement}
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindBinaryStream(int parameterIndex, InputStream in) throws SQLException {
        delegate().setBinaryStream(parameterIndex, in);
        return this;
    }

    /**
     * Sets the designated parameter to the given input stream, which will have the specified number of bytes. When a very
     * large binary value is input to a {@code LONGVARBINARY} parameter, it may be more practical to send it via a
     * {@code java.io.InputStream} object. The data will be read from the stream as needed until end-of-file is reached.
     * <p>
     * <b>Note:</b> This stream object can either be a standard Java stream object or your own subclass that implements the
     * standard interface.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param in             the java input stream which contains the binary parameter value
     * @param length         the number of bytes in the stream
     * @throws SQLException if parameterIndex does not correspond to a parameter placeholder in the SQL statement or if a
     *                      database access error occurs or this method is called on a closed {@code PreparedStatement}
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindBinaryStream(int parameterIndex, InputStream in, int length) throws SQLException {
        delegate().setBinaryStream(parameterIndex, in, length);
        return this;
    }

    /**
     * Sets the designated parameter to the given input stream, which will have the specified number of bytes. When a very
     * large binary value is input to a {@code LONGVARBINARY} parameter, it may be more practical to send it via a
     * {@code java.io.InputStream} object. The data will be read from the stream as needed until end-of-file is reached.
     * <p>
     * <b>Note:</b> This stream object can either be a standard Java stream object or your own subclass that implements the
     * standard interface.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param in             the java input stream which contains the binary parameter value
     * @param length         the number of bytes in the stream
     * @throws SQLException if parameterIndex does not correspond to a parameter placeholder in the SQL statement or if a
     *                      database access error occurs or this method is called on a closed {@code PreparedStatement}
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindBinaryStream(int parameterIndex, InputStream in, long length) throws SQLException {
        delegate().setBinaryStream(parameterIndex, in, length);
        return this;
    }

    /**
     * Sets the designated parameter to the given {@code java.sql.Blob} object. The driver converts this to an SQL
     * {@code BLOB} value when it sends it to the database.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param x              a {@code Blob} object that maps an SQL {@code BLOB} value
     * @throws SQLException                    if parameterIndex does not correspond to a parameter placeholder in the SQL
     *                                         statement or if a database access error occurs or this method is called on a
     *                                         closed {@code PreparedStatement}
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindBlob(int parameterIndex, Blob x) throws SQLException {
        delegate().setBlob(parameterIndex, x);
        return this;
    }

    /**
     * Sets the designated parameter to a {@code InputStream} object. This method differs from the
     * {@code setBinaryStream (int, InputStream)} method because it informs the driver that the parameter value should be
     * sent to the server as a {@code BLOB}. When the {@code setBinaryStream} method is used, the driver may have to do
     * extra work to determine whether the parameter data should be sent to the server as a {@code LONGVARBINARY} or a
     * {@code BLOB}
     * <p>
     * <b>Note:</b> Consult your JDBC driver documentation to determine if it might be more efficient to use a version of
     * {@code setBlob} which takes a length parameter.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param in             an object that contains the data to set the parameter value to.
     * @throws SQLException                    if parameterIndex does not correspond to a parameter placeholder in the SQL
     *                                         statement or if a database access error occurs or this method is called on a
     *                                         closed {@code PreparedStatement} or if parameterIndex does not correspond to
     *                                         a parameter placeholder in the SQL statement,
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindBlob(int parameterIndex, InputStream in) throws SQLException {
        delegate().setBlob(parameterIndex, in);
        return this;
    }

    /**
     * Sets the designated parameter to a {@code InputStream} object. The inputstream must contain the number of characters
     * specified by length otherwise a {@code SQLException} will be generated when the {@code PreparedStatement} is
     * executed. This method differs from the {@code setBinaryStream (int, InputStream, int)} method because it informs the
     * driver that the parameter value should be sent to the server as a {@code BLOB}. When the {@code setBinaryStream}
     * method is used, the driver may have to do extra work to determine whether the parameter data should be sent to the
     * server as a {@code LONGVARBINARY} or a {@code BLOB}
     * 
     * @param parameterIndex the 1-based parameter index
     * @param in             an object that contains the data to set the parameter value to.
     * @param length         the number of bytes in the parameter data.
     * @throws SQLException                    if parameterIndex does not correspond to a parameter placeholder in the SQL
     *                                         statement or if a database access error occurs or this method is called on a
     *                                         closed {@code PreparedStatement} or if the length specified is less than zero
     *                                         or if the number of bytes in the inputstream does not match the specified
     *                                         length.
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindBlob(int parameterIndex, InputStream in, long length) throws SQLException {
        delegate().setBlob(parameterIndex, in, length);
        return this;
    }

    /**
     * Sets the designated parameter to the given Java {@code boolean} value. The driver converts this to an SQL {@code BIT}
     * or {@code BOOLEAN} value when it sends it to the database.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param x              the parameter value
     * @throws SQLException if parameterIndex does not correspond to a parameter placeholder in the SQL statement or if a
     *                      database access error occurs or this method is called on a closed {@code PreparedStatement}
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindBoolean(int parameterIndex, boolean x) throws SQLException {
        delegate().setBoolean(parameterIndex, x);
        return this;
    }

    /**
     * Sets the designated parameter to the given Java {@code byte} value. The driver converts this to an SQL
     * {@code TINYINT} value when it sends it to the database.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param x              the parameter value
     * @throws SQLException if parameterIndex does not correspond to a parameter placeholder in the SQL statement or if a
     *                      database access error occurs or this method is called on a closed {@code PreparedStatement}
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindByte(int parameterIndex, byte x) throws SQLException {
        delegate().setByte(parameterIndex, x);
        return this;
    }

    /**
     * Sets the designated parameter to the given Java array of bytes. The driver converts this to an SQL {@code VARBINARY}
     * or {@code LONGVARBINARY} (depending on the argument's size relative to the driver's limits on {@code VARBINARY}
     * values) when it sends it to the database.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param x              the parameter value
     * @throws SQLException if parameterIndex does not correspond to a parameter placeholder in the SQL statement or if a
     *                      database access error occurs or this method is called on a closed {@code PreparedStatement}
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindBytes(int parameterIndex, byte x[]) throws SQLException {
        delegate().setBytes(parameterIndex, x);
        return this;
    }

    /**
     * Sets the designated parameter to the given {@code Reader} object. When a very large UNICODE value is input to a
     * {@code LONGVARCHAR} parameter, it may be more practical to send it via a {@code java.io.Reader} object. The data will
     * be read from the stream as needed until end-of-file is reached. The JDBC driver will do any necessary conversion from
     * UNICODE to the database char format.
     * <p>
     * <b>Note:</b> This stream object can either be a standard Java stream object or your own subclass that implements the
     * standard interface.
     * <p>
     * <b>Note:</b> Consult your JDBC driver documentation to determine if it might be more efficient to use a version of
     * {@code setCharacterStream} which takes a length parameter.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param reader         the {@code java.io.Reader} object that contains the Unicode data
     * @throws SQLException                    if parameterIndex does not correspond to a parameter placeholder in the SQL
     *                                         statement or if a database access error occurs or this method is called on a
     *                                         closed {@code PreparedStatement}
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindCharacterStream(int parameterIndex, Reader reader) throws SQLException {
        delegate().setCharacterStream(parameterIndex, reader);
        return this;
    }

    /**
     * Sets the designated parameter to the given {@code Reader} object, which is the given number of characters long. When
     * a very large UNICODE value is input to a {@code LONGVARCHAR} parameter, it may be more practical to send it via a
     * {@code java.io.Reader} object. The data will be read from the stream as needed until end-of-file is reached. The JDBC
     * driver will do any necessary conversion from UNICODE to the database char format.
     * <p>
     * <b>Note:</b> This stream object can either be a standard Java stream object or your own subclass that implements the
     * standard interface.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param reader         the {@code java.io.Reader} object that contains the Unicode data
     * @param length         the number of characters in the stream
     * @throws SQLException if parameterIndex does not correspond to a parameter placeholder in the SQL statement or if a
     *                      database access error occurs or this method is called on a closed {@code PreparedStatement}
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindCharacterStream(int parameterIndex, Reader reader, int length) throws SQLException {
        delegate().setCharacterStream(parameterIndex, reader, length);
        return this;
    }

    /**
     * Sets the designated parameter to the given {@code Reader} object, which is the given number of characters long. When
     * a very large UNICODE value is input to a {@code LONGVARCHAR} parameter, it may be more practical to send it via a
     * {@code java.io.Reader} object. The data will be read from the stream as needed until end-of-file is reached. The JDBC
     * driver will do any necessary conversion from UNICODE to the database char format.
     * <p>
     * <b>Note:</b> This stream object can either be a standard Java stream object or your own subclass that implements the
     * standard interface.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param reader         the {@code java.io.Reader} object that contains the Unicode data
     * @param length         the number of characters in the stream
     * @throws SQLException if parameterIndex does not correspond to a parameter placeholder in the SQL statement or if a
     *                      database access error occurs or this method is called on a closed {@code PreparedStatement}
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindCharacterStream(int parameterIndex, Reader reader, long length) throws SQLException {
        delegate().setCharacterStream(parameterIndex, reader, length);
        return this;
    }

    /**
     * Sets the designated parameter to the given {@code java.sql.Clob} object. The driver converts this to an SQL
     * {@code CLOB} value when it sends it to the database.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param x              a {@code Clob} object that maps an SQL {@code CLOB} value
     * @throws SQLException                    if parameterIndex does not correspond to a parameter placeholder in the SQL
     *                                         statement or if a database access error occurs or this method is called on a
     *                                         closed {@code PreparedStatement}
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindClob(int parameterIndex, Clob x) throws SQLException {
        delegate().setClob(parameterIndex, x);
        return this;
    }

    /**
     * Sets the designated parameter to a {@code Reader} object. This method differs from the
     * {@code setCharacterStream (int, Reader)} method because it informs the driver that the parameter value should be sent
     * to the server as a {@code CLOB}. When the {@code setCharacterStream} method is used, the driver may have to do extra
     * work to determine whether the parameter data should be sent to the server as a {@code LONGVARCHAR} or a {@code CLOB}
     * <p>
     * <b>Note:</b> Consult your JDBC driver documentation to determine if it might be more efficient to use a version of
     * {@code setClob} which takes a length parameter.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param reader         an object that contains the data to set the parameter value to.
     * @throws SQLException if parameterIndex does not correspond to a parameter placeholder in the SQL statement or if a
     *                      database access error occurs or this method is called on a closed {@code PreparedStatement} or
     *                      if parameterIndex does not correspond to a parameter placeholder in the SQL statement @throws
     *                      SQLFeatureNotSupportedException if the JDBC driver does not support this method
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindClob(int parameterIndex, Reader reader) throws SQLException {
        delegate().setClob(parameterIndex, reader);
        return this;
    }

    /**
     * Sets the designated parameter to a {@code Reader} object. The reader must contain the number of characters specified
     * by length otherwise a {@code SQLException} will be generated when the {@code PreparedStatement} is executed. This
     * method differs from the {@code setCharacterStream (int, Reader, int)} method because it informs the driver that the
     * parameter value should be sent to the server as a {@code CLOB}. When the {@code setCharacterStream} method is used,
     * the driver may have to do extra work to determine whether the parameter data should be sent to the server as a
     * {@code LONGVARCHAR} or a {@code CLOB}
     * 
     * @param parameterIndex the 1-based parameter index
     * @param reader         an object that contains the data to set the parameter value to.
     * @param length         the number of characters in the parameter data.
     * @throws SQLException if parameterIndex does not correspond to a parameter placeholder in the SQL statement or if a
     *                      database access error occurs or this method is called on a closed {@code PreparedStatement} or
     *                      if the length specified is less than zero. @throws SQLFeatureNotSupportedException if the JDBC
     *                      driver does not support this method
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindClob(int parameterIndex, Reader reader, long length) throws SQLException {
        delegate().setClob(parameterIndex, reader, length);
        return this;
    }

    /**
     * Sets the designated parameter to the given {@code java.sql.Date} value using the default time zone of the virtual
     * machine that is running the application. The driver converts this to an SQL {@code DATE} value when it sends it to
     * the database.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param x              the parameter value
     * @throws SQLException if parameterIndex does not correspond to a parameter placeholder in the SQL statement or if a
     *                      database access error occurs or this method is called on a closed {@code PreparedStatement}
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindDate(int parameterIndex, Date x) throws SQLException {
        delegate().setDate(parameterIndex, x);
        return this;
    }

    /**
     * Sets the designated parameter to the given {@code java.sql.Date} value, using the given {@code Calendar} object. The
     * driver uses the {@code Calendar} object to construct an SQL {@code DATE} value, which the driver then sends to the
     * database. With a {@code Calendar} object, the driver can calculate the date taking into account a custom timezone. If
     * no {@code Calendar} object is specified, the driver uses the default timezone, which is that of the virtual machine
     * running the application.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param x              the parameter value
     * @param cal            the {@code Calendar} object the driver will use to construct the date
     * @throws SQLException if parameterIndex does not correspond to a parameter placeholder in the SQL statement or if a
     *                      database access error occurs or this method is called on a closed {@code PreparedStatement}
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindDate(int parameterIndex, java.sql.Date x, Calendar cal) throws SQLException {
        delegate().setDate(parameterIndex, x);
        return this;
    }

    /**
     * Sets the designated parameter to the given Java {@code double} value. The driver converts this to an SQL
     * {@code DOUBLE} value when it sends it to the database.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param x              the parameter value
     * @throws SQLException if parameterIndex does not correspond to a parameter placeholder in the SQL statement or if a
     *                      database access error occurs or this method is called on a closed {@code PreparedStatement}
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindDouble(int parameterIndex, double x) throws SQLException {
        delegate().setDouble(parameterIndex, x);
        return this;
    }

    /**
     * Sets the designated parameter to the given Java {@code float} value. The driver converts this to an SQL {@code REAL}
     * value when it sends it to the database.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param x              the parameter value
     * @throws SQLException if parameterIndex does not correspond to a parameter placeholder in the SQL statement or if a
     *                      database access error occurs or this method is called on a closed {@code PreparedStatement}
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindFloat(int parameterIndex, float x) throws SQLException {
        delegate().setFloat(parameterIndex, x);
        return this;
    }

    /**
     * Sets the designated parameter to the given Java {@code int} value. The driver converts this to an SQL {@code INTEGER}
     * value when it sends it to the database.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param x              the parameter value
     * @throws SQLException if parameterIndex does not correspond to a parameter placeholder in the SQL statement or if a
     *                      database access error occurs or this method is called on a closed {@code PreparedStatement}
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindInt(int parameterIndex, int x) throws SQLException {
        delegate().setInt(parameterIndex, x);
        return this;
    }

    /**
     * Sets the designated parameter to the given Java {@code long} value. The driver converts this to an SQL {@code BIGINT}
     * value when it sends it to the database.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param x              the parameter value
     * @throws SQLException if parameterIndex does not correspond to a parameter placeholder in the SQL statement or if a
     *                      database access error occurs or this method is called on a closed {@code PreparedStatement}
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindLong(int parameterIndex, long x) throws SQLException {
        delegate().setLong(parameterIndex, x);
        return this;
    }

    /**
     * Sets the designated parameter to a {@code Reader} object. The {@code Reader} reads the data till end-of-file is
     * reached. The driver does the necessary conversion from Java character format to the national character set in the
     * database.
     * 
     * <p>
     * <b>Note:</b> This stream object can either be a standard Java stream object or your own subclass that implements the
     * standard interface.
     * <p>
     * <b>Note:</b> Consult your JDBC driver documentation to determine if it might be more efficient to use a version of
     * {@code setNCharacterStream} which takes a length parameter.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param reader         the parameter value
     * @throws SQLException                    if parameterIndex does not correspond to a parameter placeholder in the SQL
     *                                         statement or if the driver does not support national character sets or if the
     *                                         driver can detect that a data conversion error could occur or if a database
     *                                         access error occurs or or this method is called on a closed
     *                                         {@code PreparedStatement}
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindNCharacterStream(int parameterIndex, Reader reader) throws SQLException {
        delegate().setNCharacterStream(parameterIndex, reader);
        return this;
    }

    /**
     * Sets the designated parameter to a {@code Reader} object. The {@code Reader} reads the data till end-of-file is
     * reached. The driver does the necessary conversion from Java character format to the national character set in the
     * database.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param reader         the parameter value
     * @param length         the number of characters in the parameter data.
     * @throws SQLException                    if parameterIndex does not correspond to a parameter placeholder in the SQL
     *                                         statement or if the driver does not support national character sets or if the
     *                                         driver can detect that a data conversion error could occur or if a database
     *                                         access error occurs or or this method is called on a closed
     *                                         {@code PreparedStatement}
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindNCharacterStream(int parameterIndex, Reader reader, long length) throws SQLException {
        delegate().setNCharacterStream(parameterIndex, reader, length);
        return this;
    }

    /**
     * Sets the designated parameter to a {@code java.sql.NClob} object. The driver converts this to a SQL {@code NCLOB}
     * value when it sends it to the database.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param x              the parameter value
     * @throws SQLException                    if parameterIndex does not correspond to a parameter placeholder in the SQL
     *                                         statement or if the driver does not support national character sets or if the
     *                                         driver can detect that a data conversion error could occur or if a database
     *                                         access error occurs or or this method is called on a closed
     *                                         {@code PreparedStatement}
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindNClob(int parameterIndex, NClob x) throws SQLException {
        delegate().setNClob(parameterIndex, x);
        return this;
    }

    /**
     * Sets the designated parameter to a {@code Reader} object. This method differs from the
     * {@code setCharacterStream (int, Reader)} method because it informs the driver that the parameter value should be sent
     * to the server as a {@code NCLOB}. When the {@code setCharacterStream} method is used, the driver may have to do extra
     * work to determine whether the parameter data should be sent to the server as a {@code LONGNVARCHAR} or a
     * {@code NCLOB}
     * <p>
     * <b>Note:</b> Consult your JDBC driver documentation to determine if it might be more efficient to use a version of
     * {@code setNClob} which takes a length parameter.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param reader         an object that contains the data to set the parameter value to.
     * @throws SQLException                    if parameterIndex does not correspond to a parameter placeholder in the SQL
     *                                         statement or if the driver does not support national character sets or if the
     *                                         driver can detect that a data conversion error could occur or if a database
     *                                         access error occurs or this method is called on a closed
     *                                         {@code PreparedStatement}
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindNClob(int parameterIndex, Reader reader) throws SQLException {
        delegate().setNClob(parameterIndex, reader);
        return this;
    }

    /**
     * Sets the designated parameter to a {@code Reader} object. The reader must contain the number of characters specified
     * by length otherwise a {@code SQLException} will be generated when the {@code PreparedStatement} is executed. This
     * method differs from the {@code setCharacterStream (int, Reader, int)} method because it informs the driver that the
     * parameter value should be sent to the server as a {@code NCLOB}. When the {@code setCharacterStream} method is used,
     * the driver may have to do extra work to determine whether the parameter data should be sent to the server as a
     * {@code LONGNVARCHAR} or a {@code NCLOB}
     * 
     * @param parameterIndex the 1-based parameter index
     * @param reader         an object that contains the data to set the parameter value to.
     * @param length         the number of characters in the parameter data.
     * @throws SQLException                    if parameterIndex does not correspond to a parameter placeholder in the SQL
     *                                         statement or if the length specified is less than zero or if the driver does
     *                                         not support national character sets or if the driver can detect that a data
     *                                         conversion error could occur or if a database access error occurs or this
     *                                         method is called on a closed {@code PreparedStatement}
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindNClob(int parameterIndex, Reader reader, long length) throws SQLException {
        delegate().setNClob(parameterIndex, reader, length);
        return this;
    }

    /**
     * Sets the designated parameter to the given {@code String} object. The driver converts this to a SQL {@code NCHAR} or
     * {@code NVARCHAR} or {@code LONGNVARCHAR} value (depending on the argument's size relative to the driver's limits on
     * {@code NVARCHAR} values) when it sends it to the database.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param x              the parameter value
     * @throws SQLException                    if parameterIndex does not correspond to a parameter placeholder in the SQL
     *                                         statement or if the driver does not support national character sets or if the
     *                                         driver can detect that a data conversion error could occur or if a database
     *                                         access error occurs or or this method is called on a closed
     *                                         {@code PreparedStatement}
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindNString(int parameterIndex, String x) throws SQLException {
        delegate().setNString(parameterIndex, x);
        return this;
    }

    /**
     * Sets the designated parameter to SQL {@code NULL}.
     * <p>
     * <b>Note:</b> You must specify the parameter's SQL type.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param sqlType        the SQL type code defined in {@code java.sql.Types}
     * @throws SQLException                    if parameterIndex does not correspond to a parameter placeholder in the SQL
     *                                         statement or if a database access error occurs or this method is called on a
     *                                         closed {@code PreparedStatement}
     * @throws SQLFeatureNotSupportedException if {@code sqlType} is a {@code ARRAY}, {@code BLOB}, {@code CLOB},
     *                                         {@code DATALINK}, {@code JAVA_OBJECT}, {@code NCHAR}, {@code NCLOB},
     *                                         {@code NVARCHAR}, {@code LONGNVARCHAR}, {@code REF}, {@code ROWID},
     *                                         {@code SQLXML} or {@code STRUCT} data type and the JDBC driver does not
     *                                         support this data type
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindNull(int parameterIndex, int sqlType) throws SQLException {
        delegate().setNull(parameterIndex, sqlType);
        return this;
    }

    /**
     * Sets the designated parameter to SQL {@code NULL}. This version of the method {@code setNull} should be used for
     * user-defined types and REF type parameters. Examples of user-defined types include: STRUCT, DISTINCT, JAVA_OBJECT,
     * and named array types.
     * <p>
     * <b>Note:</b> To be portable, applications must give the SQL type code and the fully-qualified SQL type name when
     * specifying a NULL user-defined or REF parameter. In the case of a user-defined type the name is the type name of the
     * parameter itself. For a REF parameter, the name is the type name of the referenced type. If a JDBC driver does not
     * need the type code or type name information, it may ignore it. Although it is intended for user-defined and Ref
     * parameters, this method may be used to set a null parameter of any JDBC type. If the parameter does not have a
     * user-defined or REF type, the given typeName is ignored.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param sqlType        a value from {@code java.sql.Types}
     * @param typeName       the fully-qualified name of an SQL user-defined type or ignored if the parameter is not a
     *                       user-defined type or REF
     * @throws SQLException                    if parameterIndex does not correspond to a parameter placeholder in the SQL
     *                                         statement or if a database access error occurs or this method is called on a
     *                                         closed {@code PreparedStatement}
     * @throws SQLFeatureNotSupportedException if {@code sqlType} is a {@code ARRAY}, {@code BLOB}, {@code CLOB},
     *                                         {@code DATALINK}, {@code JAVA_OBJECT}, {@code NCHAR}, {@code NCLOB},
     *                                         {@code NVARCHAR}, {@code LONGNVARCHAR}, {@code REF}, {@code ROWID},
     *                                         {@code SQLXML} or {@code STRUCT} data type and the JDBC driver does not
     *                                         support this data type or if the JDBC driver does not support this method
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindNull(int parameterIndex, int sqlType, String typeName) throws SQLException {
        delegate().setNull(parameterIndex, sqlType, typeName);
        return this;
    }

    /**
     * <p>
     * Sets the value of the designated parameter using the given object.
     * <p>
     * The JDBC specification specifies a standard mapping from Java {@code Object} types to SQL types. The given argument
     * will be converted to the corresponding SQL type before being sent to the database.
     * <p>
     * Note that this method may be used to pass datatabase- specific abstract data types, by using a driver-specific Java
     * type. If the object is of a class implementing the interface {@code SQLData}, the JDBC driver should call the method
     * {@code SQLData.writeSQL} to write it to the SQL data stream. If, on the other hand, the object is of a class
     * implementing {@code Ref}, {@code Blob}, {@code Clob}, {@code NClob}, {@code Struct}, {@code java.net.URL},
     * {@code RowId}, {@code SQLXML} or {@code Array}, the driver should pass it to the database as a value of the
     * corresponding SQL type.
     * <p>
     * <b>Note:</b> Not all databases allow for a non-typed Null to be sent to the backend. For maximum portability, the
     * {@code setNull} or the {@code setObject(int parameterIndex, Object x, int sqlType)} method should be used instead of
     * {@code setObject(int parameterIndex, Object x)}.
     * <p>
     * <b>Note:</b> This method throws an exception if there is an ambiguity, for example, if the object is of a class
     * implementing more than one of the interfaces named above.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param x              the object containing the input parameter value
     * @throws SQLException if parameterIndex does not correspond to a parameter placeholder in the SQL statement or if a
     *                      database access error occurs or this method is called on a closed {@code PreparedStatement} or
     *                      the type of the given object is ambiguous
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindObject(int parameterIndex, Object x) throws SQLException {
        delegate().setObject(parameterIndex, x);
        return this;
    }

    /**
     * Sets the value of the designated parameter with the given object. This method is similar to
     * {@link #setObject(int parameterIndex, Object x, int targetSqlType, int scaleOrLength)}, except that it assumes a
     * scale of zero.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param x              the object containing the input parameter value
     * @param targetSqlType  the SQL type (as defined in java.sql.Types) to be sent to the database
     * @throws SQLException                    if parameterIndex does not correspond to a parameter placeholder in the SQL
     *                                         statement or if a database access error occurs or this method is called on a
     *                                         closed PreparedStatement
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support the specified targetSqlType
     * @see Types
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindObject(int parameterIndex, Object x, int targetSqlType) throws SQLException {
        delegate().setObject(parameterIndex, x, targetSqlType);
        return this;
    }

    /**
     * <p>
     * Sets the value of the designated parameter with the given object. If the second argument is an {@code InputStream}
     * then the stream must contain the number of bytes specified by scaleOrLength. If the second argument is a
     * {@code Reader} then the reader must contain the number of characters specified by scaleOrLength. If these conditions
     * are not true the driver will generate a {@code SQLException} when the prepared statement is executed.
     * <p>
     * The given Java object will be converted to the given targetSqlType before being sent to the database. If the object
     * has a custom mapping (is of a class implementing the interface {@code SQLData}), the JDBC driver should call the
     * method {@code SQLData.writeSQL} to write it to the SQL data stream. If, on the other hand, the object is of a class
     * implementing {@code Ref}, {@code Blob}, {@code Clob}, {@code NClob}, {@code Struct}, {@code java.net.URL}, or
     * {@code Array}, the driver should pass it to the database as a value of the corresponding SQL type.
     * <p>
     * Note that this method may be used to pass database-specific abstract data types.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param x              the object containing the input parameter value
     * @param targetSqlType  the SQL type (as defined in java.sql.Types) to be sent to the database. The scale argument may
     *                       further qualify this type.
     * @param scaleOrLength  for {@code java.sql.Types.DECIMAL} or {@code java.sql.Types.NUMERIC types}, this is the number
     *                       of digits after the decimal point. For Java Object types {@code InputStream} and
     *                       {@code Reader}, this is the length of the data in the stream or reader. For all other types,
     *                       this value will be ignored.
     * @throws SQLException                    if parameterIndex does not correspond to a parameter placeholder in the SQL
     *                                         statement or if a database access error occurs or this method is called on a
     *                                         closed {@code PreparedStatement} or if the Java Object specified by x is an
     *                                         InputStream or Reader object and the value of the scale parameter is less
     *                                         than zero
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support the specified targetSqlType
     * @see Types @return this {@code FluentStatement} instance
     */
    public FluentStatement bindObject(int parameterIndex, Object x, int targetSqlType, int scaleOrLength) throws SQLException {
        delegate().setObject(parameterIndex, targetSqlType, scaleOrLength);
        return this;
    }

    /**
     * Sets the designated parameter to the given {@code REF(&lt;structured-type&gt;)} value. The driver converts this to an
     * SQL {@code REF} value when it sends it to the database.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param ref            an SQL {@code REF} value
     * @throws SQLException                    if parameterIndex does not correspond to a parameter placeholder in the SQL
     *                                         statement or if a database access error occurs or this method is called on a
     *                                         closed {@code PreparedStatement}
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindRef(int parameterIndex, Ref ref) throws SQLException {
        delegate().setRef(parameterIndex, ref);
        return this;
    }

    /**
     * Sets the designated parameter to the given {@code java.sql.RowId} object. The driver converts this to a SQL
     * {@code ROWID} value when it sends it to the database @param parameterIndex the 1-based parameter index
     * 
     * @param rowId the parameter value
     * @throws SQLException                    if parameterIndex does not correspond to a parameter placeholder in the SQL
     *                                         statement or if a database access error occurs or this method is called on a
     *                                         closed {@code PreparedStatement}
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindRowId(int parameterIndex, RowId rowId) throws SQLException {
        delegate().setRowId(parameterIndex, rowId);
        return this;
    }

    /**
     * Sets the designated parameter to the given Java {@code short} value. The driver converts this to an SQL
     * {@code SMALLINT} value when it sends it to the database.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param x              the parameter value
     * @throws SQLException if parameterIndex does not correspond to a parameter placeholder in the SQL statement or if a
     *                      database access error occurs or this method is called on a closed {@code PreparedStatement}
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindShort(int parameterIndex, short x) throws SQLException {
        delegate().setShort(parameterIndex, x);
        return this;
    }

    /**
     * Sets the designated parameter to the given {@code java.sql.SQLXML} object. The driver converts this to an SQL
     * {@code XML} value when it sends it to the database.
     * <p>
     * 
     * @param parameterIndex the 1-based parameter index
     * @param xml            a {@code SQLXML} object that maps an SQL {@code XML} value
     * @throws SQLException                    if parameterIndex does not correspond to a parameter placeholder in the SQL
     *                                         statement or if a database access error occurs or this method is called on a
     *                                         closed {@code PreparedStatement} or the {@code java.xml.transform.Result},
     *                                         {@code Writer} or {@code OutputStream} has not been closed for the
     *                                         {@code SQLXML} object
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindSQLXML(int parameterIndex, SQLXML xml) throws SQLException {
        delegate().setSQLXML(parameterIndex, xml);
        return this;
    }

    /**
     * Sets the designated parameter to the given Java {@code String} value. The driver converts this to an SQL
     * {@code VARCHAR} or {@code LONGVARCHAR} value (depending on the argument's size relative to the driver's limits on
     * {@code VARCHAR} values) when it sends it to the database.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param x              the parameter value
     * @throws SQLException if parameterIndex does not correspond to a parameter placeholder in the SQL statement or if a
     *                      database access error occurs or this method is called on a closed {@code PreparedStatement}
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindString(int parameterIndex, String x) throws SQLException {
        delegate().setString(parameterIndex, x);
        return this;
    }

    /**
     * Sets the designated parameter to the given {@code java.sql.Time} value, using the given {@code Calendar} object. The
     * driver uses the {@code Calendar} object to construct an SQL {@code TIME} value, which the driver then sends to the
     * database. With a {@code Calendar} object, the driver can calculate the time taking into account a custom timezone. If
     * no {@code Calendar} object is specified, the driver uses the default timezone, which is that of the virtual machine
     * running the application.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param x              the parameter value
     * @param cal            the {@code Calendar} object the driver will use to construct the time
     * @throws SQLException if parameterIndex does not correspond to a parameter placeholder in the SQL statement or if a
     *                      database access error occurs or this method is called on a closed {@code PreparedStatement}
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindTime(int parameterIndex, Time x, Calendar cal) throws SQLException {
        delegate().setTime(parameterIndex, x);
        return this;
    }

    /**
     * Sets the designated parameter to the given {@code java.sql.Time} value. The driver converts this to an SQL
     * {@code TIME} value when it sends it to the database.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param x              the parameter value
     * @throws SQLException if parameterIndex does not correspond to a parameter placeholder in the SQL statement or if a
     *                      database access error occurs or this method is called on a closed {@code PreparedStatement}
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindTime(int parameterIndex, Time x) throws SQLException {
        delegate().setTime(parameterIndex, x);
        return this;
    }

    /**
     * Sets the designated parameter to the given {@code java.sql.Timestamp} value, using the given {@code Calendar} object.
     * The driver uses the {@code Calendar} object to construct an SQL {@code TIMESTAMP} value, which the driver then sends
     * to the database. With a {@code Calendar} object, the driver can calculate the timestamp taking into account a custom
     * timezone. If no {@code Calendar} object is specified, the driver uses the default timezone, which is that of the
     * virtual machine running the application.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param x              the parameter value
     * @param cal            the {@code Calendar} object the driver will use to construct the timestamp
     * @throws SQLException if parameterIndex does not correspond to a parameter placeholder in the SQL statement or if a
     *                      database access error occurs or this method is called on a closed {@code PreparedStatement}
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindTimestamp(int parameterIndex, Timestamp x, Calendar cal) throws SQLException {
        delegate().setTimestamp(parameterIndex, x);
        return this;
    }

    /**
     * Sets the designated parameter to the given {@code java.sql.Timestamp} value. The driver converts this to an SQL
     * {@code TIMESTAMP} value when it sends it to the database.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param x              the parameter value
     * @throws SQLException if parameterIndex does not correspond to a parameter placeholder in the SQL statement or if a
     *                      database access error occurs or this method is called on a closed {@code PreparedStatement}
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindTimestamp(int parameterIndex, Timestamp x) throws SQLException {
        delegate().setTimestamp(parameterIndex, x);
        return this;
    }

    /**
     * Sets the designated parameter to the given {@code java.net.URL} value. The driver converts this to an SQL
     * {@code DATALINK} value when it sends it to the database.
     * 
     * @param parameterIndex the 1-based parameter index
     * @param x              the {@code java.net.URL} object to be set
     * @throws SQLException                    if parameterIndex does not correspond to a parameter placeholder in the SQL
     *                                         statement or if a database access error occurs or this method is called on a
     *                                         closed {@code PreparedStatement}
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     * @return this {@code FluentStatement} instance
     */
    public FluentStatement bindURL(int parameterIndex, URL x) throws SQLException {
        delegate().setURL(parameterIndex, x);
        return this;
    }

    @Override
    public String toString() {
        return "delegate().toString(): " + super.toString();
    }

}
